目标：
1）熟练掌握gradle语法、生命周期
2）和Hook 联系起来
3）动态加载、删除组件
4）插件化、热修复：动态编译技术，在编译期间动态的在class文件中注入代码或者修改代码

Gradle资源：
https://www.jianshu.com/p/2e19268bf387
https://www.jianshu.com/p/4fbf352ffc56
Gradle用户手册：https://docs.gradle.org/current/userguide/userguide.html
组件化自动注册管理：https://www.jianshu.com/p/59368ce8b670
Gradle用户手册中文版：http://blog.didispace.com/books/GradleUserGuide/

Gradle:
1)
1、一个 Task 是 Gradle 里项目构建的原子执行单元，Gradle 通过将一个个Task串联起来完成具体的构建任务，每个 Task 都属于一个 Project
2、一个 Task 是由一序列 Action (动作)组成的，当运行一个 Task 的时候，这个 Task 里的 Action 序列会按顺序依次执行；
3、Task 里的 Action 只会在该 Task 真正运行时执行，gralde 里通过 doFirst、doLast 来为 Task 增加 Action
doFirst：task执行时最先执行的操作
doLast：task执行时最后执行的操作
4、NamedDomainObjectContainer是命名领域对象容器；
5、Project 生命周期回调
    //在 Project 进行配置前调用
    void beforeEvaluate(Closure closure)
    //在 Project 配置结束后调用
    void afterEvaluate(Closure closure)

beforeEvaluate 必须在父模块的 build.gradle 对子模块进行配置才能生效，因为在当前模块的 build.gradle 中配置，它自己本身都没配置好，所以不会监听到。

6、Gradle 属性：局部变量：def; 扩展属性使用：ext 扩展块,可以添加多个属性



2)命令(mac中)
./gradlew taskName 执行某一个task
./gradlew tasks --all 获取脚本中所有的task(包括android项目自带的task)

3)gradle的生命周期：
初始化（Initialization）
配置(Configuration)
执行（Execution）

4)自定义插件（plugin）
https://blog.csdn.net/wangzhongshun/article/details/88381058

5）Transform使用场景：
简单来说就是能够让开发者在项目构建阶段即由class到dex转换期间修改class文件，Transform阶段会扫描所有的class文件和资源文件

1、我们需要对编译class文件做自定义的处理。
2、我们需要读取编译产生的class文件，做一些其他事情，但是不需要修改它。
https://www.jianshu.com/p/031b62d02607
https://blog.csdn.net/yulong0809/article/details/77752098


相关资料
1）Gradle--语言基础Groovy;
Groovy是从Java衍生出来的，可以和Java语言混写；还需要学习Android DSL 和 Gradle DSL。
Groory语法：https://www.jianshu.com/p/fe3aede00fd3

2)调用自定义的.gradle文件
2.1)在app目录下的build.gradle配置apply from: '../groovy/XXX.gradle'
2.2)直接点击task旁边的run或者./gradlew 文件名


组件化的问题：
1）如何自动化注册组件：
解决当组件有增、删时需要，手动改变，不易维护，同时先后注册顺序需要不断变化；


组件化的核心思想：

组件化--组件自动注册方案：
1、一种更高效的组件自动注册方案(android组件化开发)：https://blog.csdn.net/cdecde111/article/details/78074692

2、Android彻底组件化demo发布--生命周期：https://www.jianshu.com/p/59822a7b2fad   特别重要
解释了字节码插入方式和反射调用方式，在什么时机加载组件，以及如何加载组件

在什么时机加载组件以及如何加载组件？目前com.dd.comgradle提供了两种方式，字节码插入和反射调用。

- 字节码插入模式是在dex生成之前，扫描所有的ApplicationLike类（其有一个共同的父类），然后通过javassist在主项目的Application.onCreate()
中插入调用ApplicationLike.onCreate()的代码。这样就相当于每个组件在application启动的时候就加载起来了。

- 反射调用的方式是手动在Application.onCreate()中或者在其他合适的时机手动通过反射的方式来调用ApplicationLike.onCreate()。
之所以提供这种方式原因有两个：对代码进行扫描和插入会增加编译的时间，特别在debug的时候会影响效率，并且这种模式对Instant Run支持不好；
另一个原因是可以更灵活的控制加载或者卸载时机。
这两种模式的配置是通过配置com.dd.comgradle的Extension来实现的，
下面是字节码插入的模式下的配置格式，添加applicationName的目的是加快定位Application的速度。

todo 反射的方式在合适加载、卸载module? 可以考虑在调用组件的时候加载，但是何时卸载呢  只能通过Application类的onTerminate()方法卸载。

3、组件生命周期管理：https://www.jianshu.com/p/65433846d38a
组件生命周期如何实现自动注册：https://www.jianshu.com/p/59368ce8b670
自定义gradle 插件： https://www.jianshu.com/p/3ec8e9574aaf

demo:
Android组件化开发实践（九）：自定义Gradle插件:
https://www.jianshu.com/p/3ec8e9574aaf
Android组件化开发实践（八）：组件生命周期如何实现自动注册管理
https://www.jianshu.com/p/59368ce8b670

- 如何调试 todo


# app 编译流程

# 打包流程

# AMS
- AMS是一个Java字节码操控框架，能够被用来动态生成类或者增强既有类的功能。

#注解 和 apt 技术
- Android & Java 注解和自定义注解处理器:https://www.jianshu.com/p/aeb93a3d33d1?from=timeline

- APT(Annotation Processing Tool)即注解处理器，是一种处理注解的工具，确切的说它是javac的一个工具，
  它用来在编译时扫描和处理注解。注解处理器以Java代码(或者编译过的字节码)作为输入，生成.java文件作为输出。
  简单来说就是在编译期，通过注解生成.java文件。
  https://www.jianshu.com/p/7af58e8e3e18

- link 注解：类标签 {@link 类名}  方法标签 {@link #方法名}

- 注解处理器调试： https://www.jianshu.com/p/e2fb317bd4de


- 解决顺序：
 1) 注解、自定义注解处理器、生成对应的类
 2) 自定义插件
 3）读取指定文件夹下的文件，然后反射初始化；



#自定义View-自定义不规则View



